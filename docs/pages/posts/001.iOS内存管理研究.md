---
title: iOS内存管理研究
date: 2023-06-21
img: https://images.unsplash.com/photo-1541029071515-84cc54f84dc5?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=1740&q=80
---



# iOS 内存管理研究

原文：[iOS 内存管理研究 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/49829766)

## 图片渲染开销

我们知道，解压后的图片是由无数像素数据组成。每个像素点通常包括红、绿、蓝和 alpha 数据，每个值都是 8 位（0–255），因此一个像素通常会占用 4 个字节（32 bit per pixel。少数专业的 app 可能会用更大的空间来表示色深，消耗的内存会相应线性增加）。

下面我们来计算一些通常的图片开销：

- 普通图片大小，如 500 * 600 * 32bpp = 1MB
- 跟 iPhone X 屏幕一样大的：1125 * 2436 * 32bpp = 10MB
- 即刻中允许最大的图片，总像素不超过1500w：15000000 * 32bpp = 57MB

有了大致的概念，以后看到一张图能简单预估，大概会吃掉多少内存。

## 缩放

- 内存开销多少与图片文件的大小（解压前的大小）没有直接关系，而是跟图片分辨率有关。举个例子：同样是 100 * 100，jpeg 和 png 两张图，文件大小可能差几倍，但是渲染后的内存开销是完全一样的——解压后的图片 buffer 大小与图片尺寸成正比，有多少像素就有多少数据。
- 通常我们下载的图片和最终展示在界面上的尺寸是不同的，有时可能需要将一张巨型图片展示在一个很小的 view 里。如果不做缩放，那么原图就会被整个解压，消耗大量内存，而很多像素点会在展示前被压缩掉，完全浪费了。所以把图片缩放到实际显示大小非常重要，而且解码量变少的话，速度也会提高很多.
- 如果在网上搜索图片缩放方案的话，一般都会找到类似“新建一个 context ，把图画在里面，再从 context 里读取图片”的答案。此时如果原图很大，那么即使缩放后的图片很小，解压原图的过程仍然需要占用大量内存资源，一不小心就会 OOM。但是如果换用 ImageIO 情况就会好很多，整个过程最多只会占用缩放后的图片所需的内存（通常只有原图的几分之一），大大减少了内存压力。

## 解码

图片解码是每个开发者都绕不过去的话题。图片从压缩的格式化数据变成像素数据需要经过解码，而解码对 CPU 和内存的开销都比较大，同时解码后的数据如何管理，如何显示都是需要我们注意的。

- 通常我们把一张图片设置到 UIImageView 上，系统会自动处理解码过程，但这样会在主线程上占用一定 CPU 资源，引起卡顿。使用 ImageIO 解码 + 后台线程执行是 WWDC(18 session 219) 推荐的做法。

- ImageIO 功能很强大，但是不支持 webp

- AsyncDisplayKit 的一大思想是拿空间换时间，换取流畅的性能，但是内存开销会比 UIKit 高。同样用一个全屏的 UIImageView 测试，直接用UIImage(named:)来设置图片，虽然不可避免要在主线程上做解压，但是消耗的内存反而较小，只有4MB（正常需要10MB）。猜测神秘的 IOSurface 对图片数据做了某些优化。苹果有这么一段话描述 IOSurface：

  ```
  Share hardware-accelerated buffer data (framebuffers and textures) across multiple processes. Manage image memory more efficiently.
  ```

  